# 5. Сравнение экземпляров класса
# Числа сравниваются по значению, строки посимвольно. Но при желании можно
# сравнивать любые объекты Python реализовав перечисленные ниже дандер
# методы.
# ● __eq__ - равно, ==
# ● __ne__ - не равно, !=
# ● __gt__ - больше, >
# ● __ge__ - не больше, меньше или равно, <=
# ● __lt__ - меньше, <
# ● __le__ - не меньше, больше или равно, >=
# Перечисленные методы попарно противоположны. Обратите внимание на
# приставку не в списке. Реализовав один из пары, второй Python попытается
# получить инвертируя значение. Не истина — это ложь, а не ложь — это истина.
# При реализации метода обычно принято возвращать True или False. Если
# возвращается другое значение в конструкциях вида if x == y:, Python применит
# функцию bool() к результату для получения True или False.
# Сравнение на идентичность, __eq__
# Создадим класс треугольник, который хранит длины трёх сторон. В первом
# варианте не будем прописывать дандер __eq__ и попробуем сравнить экземпляры.
class Triangle:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __str__(self):
        return f'Треугольник со сторонами: {self.a}, {self.b}, {self.c}'


one = Triangle(3, 4, 5)
two = one
three = Triangle(3, 4, 5)
print(one == two)
print(one == three)
# Переменные one и two равны, т.к. ссылаются на один и тот же объект в памяти. А вот
# треугольники one и three считаются разными хоть и имеют одинаковые длины
# сторон. Дело в том, что Python по умолчанию добавляет метод __eq__ следующего
# вида.
# def __eq__(self, other):
# return self is other
# Как вы помните is сравнивает адреса объектов в памяти. Следовательно проверка
# по умолчанию это: True if id(self) == id(other) else False.
