# 1. Что такое замыкания
# Функция как объект высшего порядка
# Замыкаем функцию с параметрами
# Внесём небольшие правки в пример кода:
from typing import Callable


def add_one_str(a: str) -> Callable[[str], str]:
    def add_two_str(b: str) -> str:
        return a + ' ' + b

    return add_two_str


hello = add_one_str('Hello')
bye = add_one_str('Good bye')

print(hello('world!'))
print(hello('friend!'))
print(bye('wonderful world!'))

print(f'{type(add_one_str) = }, {add_one_str.__name__ = },{id(add_one_str) = }')
print(f'{type(hello) = }, {hello.__name__ = }, {id(hello) = }')
print(f'{type(bye) = }, {bye.__name__ = }, {id(bye) = }')
# Во-первых мы не изменяли исходную функцию. Но мы создали две переменные
# hello и bye и поместили в них результат работы функции add_one_str с разными
# аргументами. Теперь мы можем вызывать новые функции и получать объединённые
# строки передавая только окончание. Первая часть строки оказалась замкнута в
# локальной области видимости. И у каждой из двух новых функций область своя и
# начало строки своё.
# А теперь посмотрите на результат работы трёх нижних строк кода. Все три
# переменные являются функциями, что очевидно. Но если функция add_one_str
# является самой собой, то функции hello и bye на самом деле являются двумя
# разными экземплярами функции add_two_str. id, т.е. адреса в оперативной памяти
# разные, а названия указывают на оригинал.
