# Урок 12. ООП. Финал

## Classwork

### Теория:

##### Термины лекции

● Дескриптор — это атрибут объекта со “связанным поведением”, то есть такой
атрибут, при доступе к которому его поведение переопределяется методом
протокола дескриптора. Эти методы __get__, __set__ и __delete__. Если хотя
бы один из этих методов определен в объекте , то можно сказать что этот
метод дескриптор.

##### Класс как функция

Метод вызова функции __call__
Python позволяет вызывать экземпляр класса как функцию
с передачей аргументов в круглых скобках
Погружение в Python | ООП. Финал
class MyFunc:
...
def __call__(self, *args, **kwargs):
...
return ...

#### Создаём итераторы

Если экземпляр класса должен итерироваться,
необходимо реализовать пару дандер методов
Погружение в Python | ООП. Финал
● __iter__ — возвращает объект итератор, например self
● __next__ — возвращает очередное значение. Для завершения
итерации вызывает исключение StopIteration

#### Создаём менеджер контекста with

Менеджер контекста with запускает два дандер метода. Один в момент вызова
менеджера, а второй в момент выхода из внутреннего блока кода.
● __enter__ — действия при входе в менеджер контекста
● __exit__ — действия при выходе из менеджера контекста

#### Декоратор @property

##### Getter

Getter — метод, выдающий себя за свойство
class Name:
...
@property
def param(self):
...
return ...

##### Setter

Setter контролирует изменение защищённого свойства через метод
class Name:
...
@property
def param(self):
...
return ...
@param.setter
def param(self, value):
...
self._param = value

#### Deleter

Deleter изменяет поведение при попытке
удалить свойство командой del
class Name:
...
@property
def param(self):
...
return ...
@param.deleter
def param(self):
...
self._param = ...

##### Экономим память

✔ Дандер __dict__ представляет словарь внутри объекта,
который хранит в качестве ключей имена атрибутов,
а в качестве значений ссылки на них. Словари
занимают много места в памяти.
✔ Дандер __slots__ представляет линейный массив,
который хранит только перечисленные переменные. 

#### Что делает __slots__
Пять причин использовать слоты из официальной документации
✔ Обеспечивает немедленное обнаружение ошибок из-за неправильного написания
атрибутов. Допускаются только имена атрибутов, указанные в __slots__
✔ Помогает создавать неизменяемые объекты, в которых дескрипторы управляют
доступом к закрытым атрибутам, хранящимся в __slots__
✔ Экономит память. В 64-битной сборке Linux экземпляр с двумя атрибутами
занимает 48 байт со __slots__ и 152 байт без него. Экономия памяти имеет
значение только тогда, когда будет создано большое количество экземпляров.
✔ Улучшает скорость. По данным на Python 3.10 на процессоре Apple M1 чтение
переменных экземпляра выполняется на 35% быстрее со __slots__().
✔ Блокирует такие инструменты как functools.cached_property(), которым
для правильной работы требуется экземплярный словарь.

### task001:

- Метод вызова функции __call__

### task002:

- Создаём итераторы

### task003:

- Создаём менеджер контекста with

### task004:

- Декоратор @property

### task005:

- Дескрипторы

### task006:

- Экономим память